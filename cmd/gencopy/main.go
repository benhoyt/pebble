package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"io"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var usage = "usage: gencopy -o outputPath package type[:receiver] [type[:receiver], ...]"

func main() {
	var outputPath string
	flag.StringVar(&outputPath, "o", "", "path of output file")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, usage+"\n")
	}
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 || outputPath == "" {
		exitErrorf(usage)
	}

	config := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(config, args[0])
	if err != nil {
		exitErrorf("error loading package: %v", err)
	}
	if len(pkgs) == 0 {
		exitErrorf("package not found")
	}
	pkg := pkgs[0]

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Generated by \"%s %s\"; DO NOT EDIT.\n\n", filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "package %s\n\n", pkg.Name)

	for _, name := range args[1:] {
		receiver := strings.ToLower(name)[:1]
		parts := strings.SplitN(name, ":", 2)
		if len(parts) == 2 {
			name = parts[0]
			receiver = parts[1]
		}

		obj := lookupType(pkg, name)
		if obj == nil {
			exitErrorf("type %q not found", name)
		}
		named, ok := obj.Type().(*types.Named)
		if !ok {
			continue
		}
		underlying := named.Underlying()
		s, ok := underlying.(*types.Struct)
		if !ok {
			exitErrorf("type %q is not a struct", name)
		}

		genCopy(&buf, obj.Name(), receiver, s)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		exitErrorf("%s\n-----\nerror formatting generated code: %v", buf.Bytes(), err)
	}

	f, err := os.Create(outputPath)
	if err != nil {
		exitErrorf("error creating output file: %v", err)
	}
	defer f.Close()
	_, err = f.Write(formatted)
	if err != nil {
		exitErrorf("error writing output: %v", err)
	}
}

func exitErrorf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}

func lookupType(pkg *packages.Package, typeName string) types.Object {
	for _, obj := range pkg.TypesInfo.Defs {
		if obj == nil {
			continue
		}
		if obj.Name() == typeName {
			return obj
		}
	}
	return nil
}

func genCopy(w io.Writer, name, receiver string, s *types.Struct) {
	fmt.Fprintf(w, "// Copy returns a deep copy of the %s.\n", name)
	fmt.Fprintf(w, "func (%s *%s) Copy() *%s {\n", receiver, name, name)
	fmt.Fprintf(w, "copied := *%s\n", receiver) // copy all value fields
	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		genCopyField(w, receiver, field.Name(), field.Type())
	}
	fmt.Fprintf(w, "return &copied\n")
	fmt.Fprintf(w, "}\n\n")
}

func genCopyField(w io.Writer, receiver, field string, t types.Type) {
	switch t := t.(type) {
	case *types.Map:
		fmt.Fprintf(w, "if %s.%s != nil {\n", receiver, field)
		fmt.Fprintf(w, "copied.%s = make(map[%s]%s, len(%s.%s))\n", field, t.Key(), typeName(t.Elem()), receiver, field)
		fmt.Fprintf(w, "for k, v := range %s.%s {\n", receiver, field)
		switch t.Elem().(type) {
		case *types.Pointer:
			fmt.Fprintf(w, "copied.%s[k] = v.Copy()\n", field)
		case *types.Basic, *types.Named:
			fmt.Fprintf(w, "copied.%s[k] = v\n", field)
		default:
			panic(fmt.Sprintf("unexpected map element type %T in field %s", t.Elem(), field))
		}
		fmt.Fprintf(w, "}\n")
		fmt.Fprintf(w, "}\n")

	case *types.Pointer:
		fmt.Fprintf(w, "if %s.%s != nil {\n", receiver, field)
		switch t.Elem().(type) {
		case *types.Named:
			fmt.Fprintf(w, "copied.%s = %s.%s.Copy()\n", field, receiver, field)
		case *types.Basic:
			fmt.Fprintf(w, "v := *%s.%s\n", receiver, field)
			fmt.Fprintf(w, "copied.%s = &v\n", field)
		default:
			panic(fmt.Sprintf("unexpected pointer type %T in field %s", t.Elem(), field))
		}
		fmt.Fprintf(w, "}\n")

	case *types.Slice:
		fmt.Fprintf(w, "if %s.%s != nil {\n", receiver, field)
		fmt.Fprintf(w, "copied.%s = make([]%s, len(%s.%s))\n", field, typeName(t.Elem()), receiver, field)
		switch t.Elem().(type) {
		case *types.Pointer:
			fmt.Fprintf(w, "for i, v := range %s.%s {\n", receiver, field)
			fmt.Fprintf(w, "copied.%s[i] = v.Copy()\n", field)
			fmt.Fprintf(w, "}\n")
		case *types.Basic, *types.Named:
			fmt.Fprintf(w, "copy(copied.%s, %s.%s)\n", field, receiver, field)
		default:
			panic(fmt.Sprintf("unexpected slice element type %T in field %s", t.Elem(), field))
		}
		fmt.Fprintf(w, "}\n")

	case *types.Named:
		genCopyField(w, receiver, field, t.Underlying())

	case *types.Basic, *types.Struct:
		// these have already been copied

	default:
		panic(fmt.Sprintf("unexpected type %T in field %s", t, field))
	}
}

func typeName(t types.Type) string {
	switch t := t.(type) {
	case *types.Pointer:
		return "*" + t.Elem().(*types.Named).Obj().Name()
	case *types.Basic:
		return t.Name()
	case *types.Named:
		return t.Obj().Name()
	default:
		panic(fmt.Sprintf("unexpected type %s", t))
	}
}
