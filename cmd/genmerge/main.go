// Generate Merge methods to "deep merge" struct types.

// NOTE: this only works on the subset of types that plan.Plan currently needs.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"io"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var usage = "usage: genmerge -o outputPath package type[:receiver] [type[:receiver], ...]"

func main() {
	var outputPath string
	flag.StringVar(&outputPath, "o", "", "path of output file")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, usage+"\n")
	}
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 || outputPath == "" {
		exitErrorf(usage)
	}

	config := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(config, args[0])
	if err != nil {
		exitErrorf("error loading package: %v", err)
	}
	if len(pkgs) == 0 {
		exitErrorf("package not found")
	}
	pkg := pkgs[0]

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by \"genmerge %s\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "package %s\n\n", pkg.Name)

	for _, name := range args[1:] {
		receiver := strings.ToLower(name)[:1]
		parts := strings.SplitN(name, ":", 2)
		if len(parts) == 2 {
			name = parts[0]
			receiver = parts[1]
		}

		obj := lookupType(pkg, name)
		if obj == nil {
			exitErrorf("type %q not found", name)
		}
		named, ok := obj.Type().(*types.Named)
		if !ok {
			continue
		}
		underlying := named.Underlying()
		s, ok := underlying.(*types.Struct)
		if !ok {
			exitErrorf("type %q is not a struct", name)
		}

		genMerge(&buf, obj.Name(), receiver, s)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		exitErrorf("%s\n-----\nerror formatting generated code: %v", buf.Bytes(), err)
	}

	f, err := os.Create(outputPath)
	if err != nil {
		exitErrorf("error creating output file: %v", err)
	}
	defer f.Close()
	_, err = f.Write(formatted)
	if err != nil {
		exitErrorf("error writing output: %v", err)
	}
}

func exitErrorf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}

func lookupType(pkg *packages.Package, typeName string) types.Object {
	for _, obj := range pkg.TypesInfo.Defs {
		if obj == nil {
			continue
		}
		if obj.Name() == typeName {
			return obj
		}
	}
	return nil
}

func genMerge(w io.Writer, name, receiver string, s *types.Struct) {
	fmt.Fprintf(w, "// Merge merges the fields set in other into %s.\n", receiver)
	fmt.Fprintf(w, "func (%s *%s) Merge(other *%s) {\n", receiver, name, name)
	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		genMergeField(w, receiver, field.Name(), field.Type())
	}
	fmt.Fprintf(w, "}\n\n")
}

func genMergeField(w io.Writer, receiver, field string, t types.Type) {
	switch t := t.(type) {
	case *types.Map:
		fmt.Fprintf(w, "for k, v := range other.%s {\n", field)
		fmt.Fprintf(w, "if %s.%s == nil {\n", receiver, field) // TODO: do this outside the loop
		fmt.Fprintf(w, "%s.%s = make(map[%s]%s)\n", receiver, field, t.Key(), typeName(t.Elem()))
		fmt.Fprintf(w, "}\n")
		fmt.Fprintf(w, "%s.%s[k] = v\n", receiver, field)
		fmt.Fprintf(w, "}\n")

	case *types.Pointer:
		fmt.Fprintf(w, "if other.%s != nil {\n", field)
		switch elemType := t.Elem().(type) {
		case *types.Named:
			fmt.Fprintf(w, "if %s.%s == nil {\n", receiver, field)
			fmt.Fprintf(w, "%s.%s = &%s{}\n", receiver, field, elemType.Obj().Name())
			fmt.Fprintf(w, "}\n")
			fmt.Fprintf(w, "%s.%s.Merge(other.%s)\n", receiver, field, field)
		case *types.Basic:
			fmt.Fprintf(w, "v := *other.%s\n", field)
			fmt.Fprintf(w, "%s.%s = &v\n", receiver, field)
		default:
			panic(fmt.Sprintf("unexpected pointer type %T in field %s", t.Elem(), field))
		}
		fmt.Fprintf(w, "}\n")

	case *types.Slice:
		fmt.Fprintf(w, "%s.%s = append(%s.%s, other.%s...)\n", receiver, field, receiver, field, field)

	case *types.Named:
		genMergeField(w, receiver, field, t.Underlying())

	case *types.Basic:
		zero := `""`
		if t.Kind() != types.String {
			zero = "0"
		}
		fmt.Fprintf(w, "if other.%s != %s {\n", field, zero)
		fmt.Fprintf(w, "%s.%s = other.%s\n", receiver, field, field)
		fmt.Fprintf(w, "}\n")

	case *types.Struct:
		fmt.Fprintf(w, "if other.%s.IsSet {\n", field)
		fmt.Fprintf(w, "%s.%s = other.%s\n", receiver, field, field)
		fmt.Fprintf(w, "}\n")

	default:
		panic(fmt.Sprintf("unexpected type %T in field %s", t, field))
	}
}

func typeName(t types.Type) string {
	switch t := t.(type) {
	case *types.Pointer:
		return "*" + t.Elem().(*types.Named).Obj().Name()
	case *types.Basic:
		return t.Name()
	case *types.Named:
		return t.Obj().Name()
	default:
		panic(fmt.Sprintf("unexpected type %s", t))
	}
}
